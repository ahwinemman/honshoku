SOLID PRINCIPLES
Summary from https://www.baeldung.com/solid-principles
1. Single Responsibility - A class should have only one responsiblity and hence only one reason to change.
     Benefits:
     Testing – A class with one responsibility will have far fewer test cases
     Lower coupling – Less functionality in a single class will have fewer dependencies
     Organization – Smaller, well-organized classes are easier to search than monolithic ones
2. Open for Extension / Closed for Modification - Classes should be open for extension, but closed for modification.
   Hence we stop ourselves from modifying existing code and causing potential new bugs. 
3. Liskov Substitution - If class A is a subtype of class B, then we should be able to replace B with A without disrupting the
   behaviour of our program.
       Basically classes that implement a base interface or class should act similarly
       Ps: It is not necessary to use the @override annotation but it gives some clarity.
4. Interface Segregation - Larger Interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need
   to be concerned about the methods that are of interest to them.
       Implementing classes have the power to implement multiple interfaces.
5. Dependency Inversion - refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules,
   both will depend on abstractions. This allows us to easily switch out dependencies as we simply inject the dependency's abstractions.

A method signature is part of the method declaration. It's the combination of the method name and the parameter list.
Emphasis is on these two properties cause of overloading where methods with the same name accept different parameters.
The implicit parameter in Java is the object that the method belongs to.